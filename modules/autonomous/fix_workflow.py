#!/usr/bin/env python3
"""
Autonomous Fix Workflow
=======================

Complete end-to-end workflow for autonomous code fixing.
Ties together: monitoring ‚Üí classification ‚Üí fix generation ‚Üí GitHub commit ‚Üí deployment.
"""

import asyncio
from typing import Dict, Optional
from datetime import datetime

from .monitor import RailwayLogMonitor
from .classifier import IssueClassifier, ApprovalLevel
from .logger import ActionLogger, BrainAction
from .github_manager import GitHubManager
from .fix_generator import AIFixGenerator


class AutonomousFixWorkflow:
    """Complete autonomous fix workflow"""
    
    def __init__(self):
        self.monitor = RailwayLogMonitor()
        self.classifier = IssueClassifier()
        self.logger = ActionLogger()
        self.github = GitHubManager()
        self.ai_fixer = AIFixGenerator()
        
        print("üîÑ Autonomous Fix Workflow initialized")
    
    async def auto_fix_issue(self, issue: Dict, file_path: str) -> bool:
        """
        Automatically fix an issue
        
        Args:
            issue: Classified issue
            file_path: Path to file needing fix
            
        Returns:
            True if fix was successful
        """
        
        print(f"\n{'='*60}")
        print(f"üîß AUTO-FIX WORKFLOW STARTED")
        print(f"{'='*60}")
        print(f"Issue: {issue['description']}")
        print(f"File: {file_path}")
        print(f"Type: {issue['issue_type']}\n")
        
        try:
            # Step 1: Read current code from GitHub
            print("1Ô∏è‚É£  Reading current code from GitHub...")
            current_code = self.github.read_file(file_path)
            if not current_code:
                print("‚ùå Could not read file")
                return False
            
            # Step 2: Generate fix with AI
            print("\n2Ô∏è‚É£  Generating AI fix...")
            fix_data = await self.ai_fixer.generate_fix(
                issue_description=issue['description'],
                current_code=current_code,
                file_path=file_path,
                issue_type=issue['issue_type']
            )
            
            if not fix_data:
                print("‚ùå Failed to generate fix")
                return False
            
            # Check confidence threshold
            if fix_data['confidence'] < 90:
                print(f"‚ö†Ô∏è  Confidence too low ({fix_data['confidence']}%), requesting approval")
                return await self.request_approval_workflow(issue, fix_data, file_path)
            
            # Step 3: Validate fix
            print("\n3Ô∏è‚É£  Validating fix...")
            validation = await self.ai_fixer.validate_fix(fix_data['fixed_code'], current_code)
            
            if validation.get('recommendation') != 'approve':
                print(f"‚ö†Ô∏è  Validation failed: {validation.get('reasoning')}")
                return False
            
            # Step 4: Create fix branch
            print("\n4Ô∏è‚É£  Creating fix branch...")
            branch_name = f"brain-auto-fix/{issue['issue_type']}-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
            
            if not self.github.create_branch(branch_name):
                print("‚ùå Failed to create branch")
                return False
            
            # Step 5: Commit fix
            print("\n5Ô∏è‚É£  Committing fix to GitHub...")
            commit_message = f"""ü§ñ Auto-fix: {issue['issue_type']}

Issue: {issue['description']}
Confidence: {fix_data['confidence']}%
Risk: {fix_data.get('risk_level', 'low')}

Changes:
{chr(10).join(f'- {change}' for change in fix_data.get('changes_made', []))}

Generated by Autonomous Brain
"""
            
            if not self.github.commit_file(
                filepath=file_path,
                content=fix_data['fixed_code'],
                commit_message=commit_message,
                branch=branch_name
            ):
                print("‚ùå Failed to commit")
                return False
            
            # Step 6: Auto-merge or create PR
            print("\n6Ô∏è‚É£  Merging changes...")
            
            # For low-risk, high-confidence fixes: auto-merge
            if fix_data.get('risk_level') == 'low' and fix_data['confidence'] >= 95:
                print("   ‚Üí Auto-merging (low risk, high confidence)")
                # Create PR (Railway will auto-deploy when merged)
                pr_url = self.github.create_pull_request(
                    title=f"ü§ñ Auto-fix: {issue['issue_type']}",
                    body=f"**Automated fix by Brain**\n\n{fix_data['explanation']}\n\nConfidence: {fix_data['confidence']}%",
                    head_branch=branch_name
                )
                
                if pr_url:
                    print(f"‚úÖ PR created: {pr_url}")
                    print("   (Auto-merge will happen after CI passes)")
                else:
                    print("‚ùå Failed to create PR")
                    return False
            else:
                # For medium/high risk: request approval
                print("   ‚Üí Creating PR for human review")
                return await self.request_approval_workflow(issue, fix_data, file_path, branch_name)
            
            # Step 7: Log action
            print("\n7Ô∏è‚É£  Logging action...")
            action = BrainAction(
                timestamp=datetime.now().isoformat(),
                action_type="auto_fix",
                severity=issue['severity'],
                issue=issue['description'],
                proposed_fix=fix_data['explanation'],
                approval_required=False,
                status="completed",
                result=f"Fixed and committed to {branch_name}",
                confidence=fix_data['confidence']
            )
            
            self.logger.log_action(action)
            
            print(f"\n{'='*60}")
            print(f"‚úÖ AUTO-FIX COMPLETE!")
            print(f"{'='*60}")
            print(f"Branch: {branch_name}")
            print(f"Status: Deployed (pending Railway rebuild)")
            print(f"{'='*60}\n")
            
            return True
            
        except Exception as e:
            print(f"\n‚ùå Error in auto-fix workflow: {e}")
            return False
    
    async def request_approval_workflow(
        self, 
        issue: Dict, 
        fix_data: Dict, 
        file_path: str, 
        branch_name: Optional[str] = None
    ) -> bool:
        """
        Request human approval for a fix
        (Phase 4 will add Telegram notifications)
        """
        
        print(f"\n‚ö†Ô∏è  APPROVAL REQUIRED")
        print(f"Issue: {issue['description']}")
        print(f"Confidence: {fix_data['confidence']}%")
        print(f"Risk: {fix_data.get('risk_level', 'unknown')}")
        print(f"\nProposed fix:")
        print(fix_data['explanation'][:200] + "...")
        
        # Log as pending approval
        action = BrainAction(
            timestamp=datetime.now().isoformat(),
            action_type="pending_approval",
            severity=issue['severity'],
            issue=issue['description'],
            proposed_fix=fix_data['explanation'],
            approval_required=True,
            status="pending",
            confidence=fix_data['confidence']
        )
        
        action_id = self.logger.log_action(action)
        print(f"\nüìù Logged as pending approval: {action_id}")
        print(f"(Phase 4 will send Telegram notification to user)")
        
        return False  # Not auto-fixed, awaiting approval


if __name__ == "__main__":
    async def test_workflow():
        workflow = AutonomousFixWorkflow()
        
        # Test with mock issue
        test_issue = {
            "description": "Invalid Telegram channel configuration",
            "issue_type": "invalid_config",
            "severity": "minor",
            "confidence": 0.95
        }
        
        print("üß™ Testing Autonomous Fix Workflow\n")
        
        # For testing, we'll simulate (not actually commit)
        print("‚ö†Ô∏è  TEST MODE: Will simulate workflow without committing\n")
        
        # In real use:
        # success = await workflow.auto_fix_issue(test_issue, "modules/the_ear.py")
        
        print("‚úÖ Workflow test complete!")
        print("\nIn production, this will:")
        print("1. Read code from GitHub")
        print("2. Generate AI fix")
        print("3. Validate fix")
        print("4. Create branch")
        print("5. Commit changes")
        print("6. Auto-merge or request approval")
        print("7. Railway auto-deploys the fix!")
    
    asyncio.run(test_workflow())
